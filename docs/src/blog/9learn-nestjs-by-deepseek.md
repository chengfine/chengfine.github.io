# 【跟着 deepseek 学 NestJS】依赖注入和控制反转

---

> 依赖注入的核心是将依赖对象的创建和绑定转移到外部容器，而不是在类内部直接 new 出来。比如，如果一个服务类需要用到数据库连接，传统方式可能是在服务内部实例化数据库连接，但 DI 则是通过构造函数或属性来自动注入这个连接实例。这样做的好处是解耦，方便测试和替换。

> 控制反转则是更广泛的概念，指的是将程序的控制权交给框架或容器，而不是由开发者直接控制。比如在 Nest.js 中，框架负责管理对象的生命周期和依赖关系，而不是开发者手动处理。IoC 容器是实现这种模式的关键，它自动处理依赖的创建和注入。

> 前端的例子来类比。比如，假设有一个前端组件需要获取数据，传统方式可能在组件内部直接调用 API，但使用 DI 的话，可以将数据获取的服务通过 props 或 context 注入，这样组件不关心数据来源，只需使用即可。这类似于 React 的 Context API 或 Angular 的依赖注入系统。

> 可能你会混淆 DI 和 IoC，需要明确它们的关系：**IoC 是设计原则，DI 是实现 IoC 的一种方式**。另外，用户可能想知道为什么 Nest.js 要用这些概念，可能是因为模块化、可测试性和可维护性，所以需要强调这些优点。

> 还要注意实际应用场景，作为前端开发者，可能更关注如何组织代码、管理服务、模块化等。

### **1. 依赖注入（DI-Dependency Injection）：你点外卖，而不是自己买菜做饭**

想象你在家突然想喝奶茶，你有两种选择：

- **自己在家做（传统做法）**：你得去买茶叶、奶、糖，准备工具……最后还要洗杯子。
- **点外卖（依赖注入）：** 你直接下单，外卖小哥把奶茶送上门。你不需要关心奶茶是怎么做的，只需要“接收”它。

**DI 的核心思想就和点外卖一样：**

- 在代码中，**“依赖”是一个对象需要另一对象（比如 A 类需要用到 B 类的功能）。**
- **传统代码：** A 类自己创建一个 B 类的实例（自己买菜做饭）。
- **依赖注入：** 把 B 类的实例直接“塞”给 A 类用（外卖小哥送上门）。

**在 Nest.js 里的体现：**

- 比如一个 `UserController` 需要调用 `UserService`，不需要自己在 Controller 里 `new UserService()`。
- Nest 会自动创建 `UserService` 的实例，并把它“注入”到 `UserController` 中（通过构造函数或装饰器）。

```typescript
// UserController 不用自己创建 UserService
@Controller("users")
export class UserController {
  constructor(private readonly userService: UserService) {} // 服务被自动注入
}
```

---

### **2. 控制反转（IoC-Inversion of Control）：遥控器交给“框架”**

**IoC 的核心思想是：** 把创建和管理对象的控制权交给框架或容器，而不是自己控制。

假设你在前端用 React：

- **传统 jQuery 开发**：你需要手动操作 DOM（比如 `$('#btn').on('click', ...)`），代码的控制权在你手里。
- **React 的“控制反转”**：你只写组件和状态，React 负责更新 DOM。控制权在 React 框架手中。

**在 Nest.js 中的体现：**

- **传统开发**：你在代码里手动 `new` 对象、管理依赖关系。
- **使用 IoC 后**：Nest 框架负责创建所有对象（比如 Service、Controller），并自动处理它们之间的关系（谁依赖谁）。

**IoC 容器就像一个“对象工厂”**，你只需要告诉它：“我需要一个 UserService”，它会自动生成好并传递给你。

---

### **DI 和 IoC 的关系：**

- **依赖注入是实现控制反转的一种方式。**
- 通过 IoC（框架掌握控制权），再由 DI（自动注入依赖）来具体实现。

---

### **简单总结：为什么用它们？**

1. **解耦代码：** 类不需要关心依赖对象如何创建，更容易维护。
2. **方便测试：** 可以轻松替换依赖的模拟对象（比如 Mock 数据）。
3. **统一管理：** Nest 框架帮你在启动时自动装配所有对象的关系。

---

### **前端对比：组件依赖 props**

假设你有一个 `UserList` 组件需要 `userData`：

- **传统方式：** `UserList` 自己发请求获取数据。
- **DI 方式：** 父组件通过 `props` 传递 `userData` 给 `UserList`。

在 Nest.js 中，框架就像“全局的父组件”，帮你自动传递所有依赖的“props”（Service）给需要的类。这样就实现了代码的高内聚、低耦合！
